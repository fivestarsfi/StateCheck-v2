#include "stdlib.fc";
#include "errors.fc";

(slice, int) dict_get?(cell dict, int key_len, slice index) asm(index key_len dict) "DICTGET";

(slice, slice, int) ReadHashmap(slice src, int m) impure inline {
    if (src~load_uint(1)) {
        if (src~load_uint(1)) {
            ;; hml_same$11
            slice v = src~load_bits(1);
            int n = get_bit_size(m);
            return (src, v, n);
        } else {
            ;; hml_long$10
            int n = get_bit_size(m);
            slice s = src~load_bits(n);
            return (src, s, n);
        }
    } else {
        ;; hml_short$0
        int n = src~load_ones();
        src~load_uint(1); 
        throw_unless(1010, n <= m);
        slice s = src~load_bits(n);
        return (src, s, n);
    }
}

(slice, slice, int) FullHashmapAugNode(cell dict, int key_len, slice key) impure inline { 
    slice cs = dict.begin_parse();
    
    while (key_len > 0) {
        (cs, slice label, int l) = ReadHashmap(cs, key_len);
        
        key_len -= l;
        
        if (key_len == 0) {
            ;; first extra in the cs, second extra in the _ref
            slice extra = cs; ;; first extra
            cell extraa = cs~load_ref(); ;; second extra
            slice value = extraa.begin_parse();
            (slice dict_value, int found) = dict_get?(dict, key_len, key);
            throw_unless(707, found == -1); 
            if (found) {
                throw_unless(708, equal_slices(dict_value, value));
            }
            return (extra, value, -1);
        }
        
        ifnot (slice_has_prefix(key, label)) {
            return (null(), null(), 0);
        }
        
        key~skip_bits(l);
        int is_right = key~load_uint(1);
        cell left = cs~load_ref();
        cell right = cs~load_ref();
        
        cs = (is_right ? right : left).begin_parse();
    }
    return (null(), null(), 0);
}

int check_that_block_exists(int block_root_hash) impure inline {
    tuple prev_mc_blocks = get_prev_mc_blocks();
    int len = prev_mc_blocks.tlen();
    int i = 0;
    while (i < len) {
        tuple x = prev_mc_blocks.at(i);
        if (x.at(3) == block_root_hash) { ;; [ wc:Integer shard:Integer seqno:Integer root_hash:Integer file_hash:Integer ] = BlockId;
            return true;
        }
        i = i + 1;
    }
    return false;
}


int check_merkle_proof_valid(slice cs, int exotic?, int hash) impure inline_ref {
    ;;; ####### MERKLE PROOF VALIDATION #######
    ifnot (exotic?) {
        return 0;
    }
    ifnot (cs~load_uint(8) == 3) {
        return 0;
    }
    ifnot (cs~load_uint(256) == hash) {
        return 0;
    }
    return true;
}


int check_merkle_update_valid_return_new_hash(slice cs, int exotic?) impure inline_ref {
    ;;; ####### MERKLE UPDATE VALIDATION #######
    ifnot (exotic?) {
        return 0;
    }
    ifnot (cs~load_uint(8) == 4) {
        return 0;
    }
    cs~skip_bits(256); ;; old_hash
    return cs~load_uint(256);
}

int check_block_header_proof(cell proof_cell, int block_root_hash, int return_state_hash) impure inline_ref {
    var (ps, exotic?) = proof_cell.begin_parse_exotic();
    throw_unless(err::invalid_merkle_proof, check_merkle_proof_valid(ps, exotic?, block_root_hash));
    if (return_state_hash) {
        slice psl = ps~load_ref().begin_parse();
        psl~load_ref();
        psl~load_ref();
        cell state_update = psl~load_ref();
        var (state_update_cs, exotic?) = state_update.begin_parse_exotic();
        int state_hash = check_merkle_update_valid_return_new_hash(state_update_cs, exotic?);
        throw_unless(err::invalid_merkle_update, state_hash);
        return state_hash;
    }
    return false;
}


slice find_shard_in_bintree(cell c) impure inline {
    var (ps, exotic?) = c.begin_parse_exotic();
    if (exotic?) {
        throw_unless(err::pruned_branch_expected, ps~load_uint(8) == 1);
        return null();
    }
    if (ps~load_int(1)) { ;;bt_fork$1 {X:Type} left:^(BinTree X) right:^(BinTree X) = BinTree X;
        slice left = find_shard_in_bintree(ps~load_ref());
        slice right = find_shard_in_bintree(ps~load_ref());
        if (left.null?()) {
            return right;
        }
        else {
            return left;
        }
    }
    else { ;;bt_leaf$0 {X:Type} leaf:X = BinTree X;
        return ps;
    }
}


() check_shard_proof(cell mc_block_proof, cell mc_state_proof, int mc_block_hash, int shard_wc, int shard_block_hash) impure inline {
    int state_hash = check_block_header_proof(mc_block_proof, mc_block_hash, true);
    var (ps, exotic?) = mc_state_proof.begin_parse_exotic();
    throw_unless(err::invalid_merkle_proof, check_merkle_proof_valid(ps, exotic?, state_hash));
    slice psl = ps~load_ref().begin_parse();
    psl~load_ref(); ;; out_msg_queue_info
    psl~load_ref(); ;; accounts
    psl~load_ref(); ;; state
    slice custom = psl~load_ref().begin_parse();
    cell shards_hashes_dict = custom~load_ref();
    (slice shard_descr_bin_tree, var found?) = shards_hashes_dict.idict_get?(32, shard_wc);
    throw_unless(err::shard_not_found, found?);
    slice shard_descr = find_shard_in_bintree(begin_cell().store_slice(shard_descr_bin_tree).end_cell());
    throw_unless(err::shard_not_found_in_bintree, ~ shard_descr.null?());
    shard_descr~skip_bits(32 + 32 + 64 + 64);
    int shrd_blk_hash = shard_descr~load_uint(256);
    throw_unless(err::invalid_block_header_proof, shrd_blk_hash == shard_block_hash);
}

() check_account_state_proof(int block_root_hash, cell block_proof, cell state_proof, int account_id, slice account_state) impure inline {
    ;; already proved shard block here (masterchain if account is in masterchain)
    int state_hash = check_block_header_proof(block_proof, block_root_hash, true);
    var (ps, exotic?) = state_proof.begin_parse_exotic();
    throw_unless(err::invalid_merkle_proof, check_merkle_proof_valid(ps, exotic?, state_hash));
    slice psl = ps~load_ref().begin_parse();
    psl~load_ref(); ;; out_msg_queue_info
    slice shard_accounts = psl~load_ref().begin_parse();
    cell accounts_dict = shard_accounts~load_dict();
    (slice state_descr_bin_tree, var found?) = accounts_dict.udict_get?(32, account_id);
    throw_if(err::acc_not_found, accounts_dict.null?());
    slice key = begin_cell().store_uint(account_id, 256).end_cell().begin_parse();
    (slice extra, slice value, int found?) = FullHashmapAugNode(accounts_dict, 256, key);
    (slice state_descr_bin_tree, var found?) = accounts_dict.udict_get?(32, account_id);
    throw_unless(err::acc_not_found, found?);
    throw_unless(err::acc_hash_dismatch, value.slice_hash() == account_state.slice_hash());
    int depth = extra~load_uint(64); ;; download from extra (optional)
    int balance = extra~load_uint(256); ;; download from extra (optional)
}

slice check_proof(slice body) impure {
    int block_root_hash = body~load_uint(256);
    cell block_proof = body~load_ref();
    cell state_proof = body~load_ref();
    int account_id = body~load_uint(256);
    slice account_state = body~load_ref().begin_parse();
    cell shard_proof = body~load_dict();
    ifnot (shard_proof.null?()) {
        slice shard_proof = shard_proof.begin_parse();
        cell mc_block_proof = shard_proof~load_ref();
        cell mc_state_proof = shard_proof~load_ref();
        int mc_block_hash = shard_proof~load_uint(256);
        int shard_wc = shard_proof~load_uint(32);
        throw_unless(check_that_block_exists(mc_block_hash), err::block_not_found);
        check_shard_proof(mc_block_proof, mc_state_proof, mc_block_hash, shard_wc, block_root_hash);
    } else {
        throw_unless(check_that_block_exists(block_root_hash), err::block_not_found);
    }
    check_account_state_proof(block_root_hash, block_proof, state_proof, account_id, account_state);   
    return account_state;
}
